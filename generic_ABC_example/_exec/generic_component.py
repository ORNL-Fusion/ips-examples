#! /usr/bin/env python

"""
generic_component 10/27/2020 (Batchelor)

A simple IPS component wrapper for the case that the only thing needed is the staging
of input and state files to the work directory, execution of the physics code, and updating 
of state files and archiving of the output files.  It does no processing of the input and
state files nor processing of the output files and state files which have been modified by
the physics code.  In other words it is useful if the user has in hand, or other components
produce, input files readable by the physics code, and the code output files can be used 
as is.  The component is generic in that it can, without modification, wrap any physics 
code for use with IPS.  It could also be used as a starting template for a more general 
component.  The specification of all aspects of the component to be implemented occurs in 
the simulation configuration file.

There are three classes of files specified in the config file: 
1) Input files which are likely used only by the physics code and are the static during  
   the workflow
2) State files which are used by multiple components and change during the course of the
   workflow.  Some state files will serve as inputs to the physics code, other state files
   will be physics code outputs that are used by other components.
3) Output files generated by the physics code but are not needed by other components

An input directory must be specified in the simulation config file which contains the input
files and any state files that the component is responsible for providing initially. The
framework maintains a state directory which contains the current set of state files and
moves state files in and out as they are produced and needed by various components.  If the
input directory contains files that are also state files then the component 'init' function 
stages these into the simulation state directory.  State file initialization can also be  
done in the simulation INIT component using the basic_init.py code.

Output files are archived to an appropriate subdirectory  of the /simulation_results/ 
directory.

Configuration parameters:

[generic_component]
# Machine dependent config info
    BIN_PATH = Path to this component script
    SCRIPT = $BIN_PATH/generic_component.py
    EXECUTABLE = Path to physics code
# Static config info
    CLASS = Class of physics component (e.g. rf)
    SUB_CLASS = Subclass of physics component (e.g. ic)
    NAME = generic_component (name of this component, i.e. implemented by generic_component.py)
    NPROC = number of processors required 
    INPUT_DIR =  Path to input directory
    INPUT_FILES = list of input files, including any state files which this component initailizes
    OUTPUT_FILES = list of output files to be archived
    STATE_FILES = list of state files used by EXECUTABLE (input or output)
    RESTART_FILES = files needed for restart

"""

import utils.simple_assignment_file_edit as edit
import utils.get_IPS_config_parameters as config
from component import Component


class generic_component (Component):
    def __init__(self, services, config):
        Component.__init__(self, services, config)
        print('Created %s' % (self.__class__))

# ------------------------------------------------------------------------------
#
# init function
#
# Moves the state files that this component is responsible for initializing into the
# state work directory.  If there are none there is nothing to do.
#
# ------------------------------------------------------------------------------

    def init(self, timeStamp=0):
        print('generic_component.init() called')

        if (self.services is None):
            message = 'Error in generic_component init (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

    # Get global configuration parameters (none for pure generic component)
 
    # Get component-specific configuration parameters. Note: Not all of these
    # are used in 'init' but if any are missing we get an exception now
    # instead of later
        BIN_PATH = config.get_component_param(self, services, 'BIN_PATH')
        RESTART_FILES = config.get_component_param(self, services, 'RESTART_FILES')
        NPROC = config.get_component_param(self, services, 'NPROC')
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')

# Nota Bene: To initialize state files initialized by this component we get state files 
# first, then input files.  That way state files in the input directory overwrite dummy
# files generated by the INIT component. It's reversed on STEP.

    # Copy state files over to working directory
        try:
            services.stage_state()
        except Exception as e:
            print('Error in call to stage_state()', e)
            services.exception('Error in call to stage_state()')
            raise

    # Get input files
        try:
            services.stage_input_files(self.INPUT_FILES)
        except Exception as e:
            print('Error in call to stageInputFiles()', e)
            self.services.exception('Error in call to stage_input_files()')
            raise


    # Update  state files in state work directory
        try:
            services.update_state()
        except Exception:
            message = 'Error in call to update_state()'
            print(message)
            services.exception(message)
            raise

        return

# ------------------------------------------------------------------------------
#
# RESTART function
# Gets restart files from restart directory
# Loads the global configuration parameters from the config file
#
# ------------------------------------------------------------------------------

    def restart(self, timeStamp):
        print('generic_component.restart() called')

        if (self.services is None):
            message = 'Error in generic_component restart(): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

        # Get restart files listed in config file.
        restart_root = config.get_global_param(self, services, 'RESTART_ROOT')
        restart_time = config.get_global_param(self, services, 'RESTART_TIME')

        try:
            services.get_restart_files(
                restart_root, restart_time, self.RESTART_FILES)
        except Exception:
            message = 'Error in call to get_restart_files()'
            print(message)
            self.services.exception(message)
            raise
        return 0

# ------------------------------------------------------------------------------
#
# STEP function
#
# Runs the "physics code"
#
# ------------------------------------------------------------------------------

    def step(self, timeStamp):
        print('generic_component.step() called')

        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services

    # Get global configuration parameters if any (none for pure generic component)

    # Get component-specific configuration parameters.
        BIN_PATH = config.get_component_param(self, services, 'BIN_PATH')
        NPROC = config.get_component_param(self, services, 'NPROC')
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE', verbose=False)

# Nota Bene: On STEP we get input files first then state.  That way any initial state files
# input directory are overwritten by the current files in state.  It's reversed on INIT.

    # Get input files
        try:
            services.stage_input_files(self.INPUT_FILES)
        except Exception:
            print('Error in call to stageInputFiles()')
            self.services.exception('Error in call to stageInputFiles()')
            raise

    # Copy state files over to working directory
        try:
            services.stage_state()
        except Exception as e:
            print('Error in call to stage_state()', e)
            services.exception('Error in call to stage_state()')
            raise

    # Run code
        cmd = EXECUTABLE
        print('Executing = ', cmd)
        services.send_portal_event(event_type='COMPONENT_EVENT',event_comment=cmd)
        cwd = services.get_working_dir()
        task_id = services.launch_task(NPROC, cwd, cmd)
        retcode = services.wait_task(task_id)
        if (retcode != 0):
            message = 'Error executing ', cmd
            print(message)
            self.services.error(message)
            raise Exception(message)
        print(cmd, ' finished \n')


# Update state files in state work directory
        try:
            services.update_state()
        except Exception:
            message = 'Error in call to update_state()'
            print(message)
            services.error(message)
            raise

# "Archive" output files in history directory
        try:
            services.stage_output_files(timeStamp, self.OUTPUT_FILES)
        except Exception:
            message = 'Error in call to stage_output_files()'
            print(message)
            services.error(message)
            raise

        return

# ------------------------------------------------------------------------------
#
# checkpoint function
# Saves  state files to restart directory
#
# ------------------------------------------------------------------------------

    def checkpoint(self, timestamp=0.0):
        print('generic_component.checkpoint() called')
        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')
        if (self.services is None):
            message = 'Error in generic_component init (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        services.save_restart_files(timestamp, self.RESTART_FILES)
        return 0

# ------------------------------------------------------------------------------
#
# finalize function
#
# Does nothing
# ------------------------------------------------------------------------------

    def finalize(self, timestamp=0.0):
        print('generic_component finalize() called')
        if (self.services is None):
            message = 'Error in generic_component step (): No self.services'
            print(message)
            raise Exception(message)
        services = self.services
        EXECUTABLE = config.get_component_param(self, services, 'EXECUTABLE')
